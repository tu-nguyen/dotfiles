#!/usr/bin/env bash

pre_r() {
    unset DOTFILES_LOADED
    unset BASH_STYLE_LOADED

    if [[ "$(pwd)" == *"/dotfiles" ]]; then
        IS_PROJECT_ROOT=true
        DOTFILES_REPO_DIR=$(pwd)
    else
        IS_PROJECT_ROOT=false

        # --- Start Load Configuration ---
        if [ -z "$DOTFILES_CONFIG_FILE" ]; then
            DOTFILES_CONFIG_FILE="$HOME/.config/dotfiles/.dotfile_config.env"
        fi

        if [ -f "$DOTFILES_CONFIG_FILE" ]; then
            source "$DOTFILES_CONFIG_FILE"
        else
            echo "[Error] Configuration file not found at $DOTFILES_CONFIG_FILE" >&2
            exit 1
        fi

        DOTFILES_CONFIG_DIR="$HOME/.config/dotfiles"
        [[ -f "$DOTFILES_CONFIG_DIR/.init" ]] && . "$DOTFILES_CONFIG_DIR/.init"
        # --- End Load Configuration ---
    fi

    echo "[INFO] Resetting settings.."
    if [ "$IS_PROJECT_ROOT" = false ]; then
      if [[ -n "$DOTFILES_REPO_DIR" ]]; then
        pushd $DOTFILES_REPO_DIR > /dev/null
      else
        echo "[ERROR] You are not in the root of the dotfile project! DOTFILES_REPO_DIR is not set. Exiting.."
        return 1
      fi
    fi

    unset BASH_STYLE_LOADED
}

post_r() {
    if [ "$IS_PROJECT_ROOT" = false ]; then
      popd > /dev/null
    fi

    # DOTFILES_CONFIG_DIR="$HOME/.config/dotfiles"
    # [[ -f "$DOTFILES_CONFIG_DIR/.bash_style" ]] && . "$DOTFILES_CONFIG_DIR/.bash_style"

    # t SUCCESS "${SUCCESS}All set!${NC}"
}

# Re-run Dotfile installation
r() {
    pre_r

    ./install.sh

    post_r
}

# Re-run just bashrc installation
rr() {
    pre_r

    FORCE_YES=1 ./install.sh skip

    post_r
}

# Copy generic .bash_twork starter file
set-tworktt() {
    if [ -z "$DOTFILES_REPO_DIR" ]; then
		t ERROR "DOTFILES_REPO_DIR not set, check $HOME/.config/dotfiles/.dotfile_config.env"
        exit 1
	else
        if [ -z "$DOTFILES_CONFIG_DIR" ]; then
            DOTFILES_CONFIG_DIR="$HOME/.config/dotfiles"
        fi

		t "Generating basic tworktt file"
        TWORKTT_FILE="$DOTFILES_REPO_DIR/twork-template.txt"
        if [ -f "$TWORKTT_FILE" ]; then
            cpp -q "$TWORKTT_FILE" "$DOTFILES_CONFIG_DIR/.bash_twork"
            t SUCCESS "All set! Remember to edit .bash_twork"
        else
            t Error "twork-template.txt file not found at $DOTFILES_REPO_DIR" >&2
            exit 1
        fi
	fi
}

# Extract a file
ex() {
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)   tar xvjf $1    ;;
            *.tar.gz)    tar xvzf $1    ;;
            *.bz2)       bunzip2 $1     ;;
            *.rar)       unrar x $1       ;;
            *.gz)        gunzip $1      ;;
            *.tar)       tar xvf $1     ;;
            *.tbz2)      tar xvjf $1    ;;
            *.tgz)       tar xvzf $1    ;;
            *.zip)       unzip $1       ;;
            *.Z)         uncompress $1  ;;
            *.7z)        7z x $1        ;;
            *)           t ERROR "don't know how to extract '$1'.." ;;
        esac
    else
        t ERROR "'$1' is not a valid file!"
    fi
 }

# Display a PDF of a given man page
pdfman() {
    man -t $@ | pstopdf -i -o /tmp/$1.pdf && open /tmp/$1.pdf
}

# Print env, use -l to only display core details
printv() {
    local show_limited=false
    local env_file=""
    local limit_vars=("BASE_URL" "ALLOWED_HOSTS" "ENFIRONMENT", "POSTGRES_HOST", "POSTGRES_DB")

    # Check for -l flag
    if [[ "$1" == "-l" ]]; then
        show_limited=true
    fi

    # Search for .env in current and up to two parent directories
    for dir in "." ".." "../.."; do
        if [[ -f "$dir/.env" ]]; then
        env_file="$dir/.env"
        break
        fi
    done

    if [[ -z "$env_file" ]]; then
        t "No .env file found in current or parent directories"
        return 1
    fi

    t "Found .env at: $env_file"

    if $show_limited; then
        for var in "${limit_vars[@]}"; do
        grep -E "^$var=" "$env_file"
        done
    else
        cat "$env_file"
    fi
}

# Searches for text in all files in the current folder
ftext() {
	# -i case-insensitive
	# -I ignore binary files
	# -H causes filename to be printed
	# -r recursive search
	# -n causes line number to be printed
	# optional: -F treat search term as a literal, not a regular expression
	# optional: -l only print filenames and not the matching lines ex. grep -irl "$1" *
	grep -iIHrn --color=always "$1" . | less -r
}

# Copy file with a progress bar
cpp() {
    local quiet=""
    local src=""
    local dest=""

    if [[ "$1" == "-q" ]]; then
        quiet=true
        src="$2"
        dest="$3"
    else
        src="$1"
        dest="$2"
    fi

    if [[ -z "$src" ]] || [[ -z "$dest" ]]; then
        t ERR "Usage: cpp [-q] <source> <destination>"
        return 1
    fi

    rsync -ah --info=progress2 "$src" "$dest"
    printf "\033[1A\r\033[K"

    if [[ -n "$quiet" ]]; then
        t OK "Transfer of $(basename "$dest") complete."
    fi

    # alt
    # local size=$(stat -c '%s' "$1")
    # pv -s "$size" "$1" > "$2"
}

# Find a file with a pattern in name:
ff() {
    find . -type f -iname '*'"$*"'*' -ls ;
}

# Helper functions

# general
# Display date and time
function now() {
    echo "$(date +"%d-%m-%Y") $(date +"%T")"
}

# Truncate text to a maximum length
function truncate_text() {
    local text="$1"
    local maxlen="${2:-30}"
    if [ ${#text} -gt "$maxlen" ]; then
        echo "${text:0:$((maxlen-3))}.."
    else
        echo "$text"
    fi
}

# Helper: get color for a status
function status_colour() {
    local status="$1"
    case "$status" in
        "To Do"|"New"|*"On Deck"*|"Story"|"Task") echo "$PINK" ;;
        "In Progress"|"Active"|*"In Progress"*|"Epic") echo "$CYAN" ;;
        "Done"|"Closed"|"Completed"|"Resolved"|*"Done"*) echo "$GREEN" ;;
        "Blocked"|*"In Review"*|"Bug"|"IT") echo "$RED" ;;
        *) echo "$WHITE" ;;
    esac
}

# Internal helper to handle the browser opening logic
function _browser_open() {
    local url="$1"

    if [[ -n "$WSL_DISTRO_NAME" ]]; then
        # WSL: Open in Windows default browser
        powershell.exe -NoProfile -Command "Start-Process '$url'"
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS: Open in default Mac browser
        open "$url"
    else
        # Standard Linux: Use xdg-open
        xdg-open "$url" 2>/dev/null
    fi
}

# DuckDuckGo Search
ddg() {
    if [[ -z "$1" ]]; then
        t ERR "Usage: ddg <query>"
        return 1
    fi
    local query=$(printf "%s+" "$@")
    _browser_open "https://duckduckgo.com/?q=${query%?}"
}

# Dictionary Search (Merriam-Webster)
dict() {
    [[ -z "$1" ]] && { t ERR "Usage: dict <word>"; return 1; }
    _browser_open "https://www.merriam-webster.com/dictionary/$1"
}

# Urban Dictionary (Slang)
urban() {
    [[ -z "$1" ]] && { t ERR "Usage: urban <query>"; return 1; }
    local query=$(printf "%s+" "$@")
    _browser_open "https://www.urbandictionary.com/define.php?term=${query%?}"
}

# YouTube Search
yt() {
    if [[ -z "$1" ]]; then
        t ERR "Usage: yt <query>"
        return 1
    fi
    local query=$(printf "%s+" "$@")
    _browser_open "https://www.youtube.com/results?search_query=${query%?}"
}

# Google Search
gg() {
    if [[ -z "$1" ]]; then
        t ERR "Usage: google <query>"
        return 1
    fi
    local query=$(printf "%s+" "$@")
    _browser_open "https://www.google.com/search?q=${query%?}"
}

# Asana Search
as() {
    local me_flag=""
    local status_flag=""
    local args=()

    local env_file="$HOME/.config/dotfiles/.dotfile_config/.dotfile_config.env"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --me)
                if [[ -f "$env_file" ]]; then
                    # Extract ASANA USER ID
                    local my_id=$(grep "^ASANA_ME_ID=" "$env_file" | cut -d'=' -f2 | tr -d '\r')

                    if [[ -n "$my_id" ]]; then
                        me_flag="&assignees.ids=${my_id}"
                    else
                        # This does nothing tbh
                        t ERR "ASANA_ME_ID not found in $env_file. Falling back to 'me'."
                        me_flag="&assignees.ids=me"
                    fi
                else
                    t ERR "Config file not found: $env_file"
                    me_flag="&assignees.ids=me"
                fi
                shift
                ;;
            --status)
                # Map the user input to Asana's URL parameters
                case "$2" in
                    completed) status_flag="&completion=complete" ;;
                    incomplete) status_flag="&completion=incomplete" ;;
                    deleted)   status_flag="&deleted=true" ;;
                    *) t ERR "Status must be: incomplete, completed, or deleted" && return 1 ;;
                esac
                shift 2
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done

    # Check if we have a query
    if [[ ${#args[@]} -eq 0 ]]; then
        t ERR "Usage: as [--me] [--status <type>] <query>"
        return 1
    fi

    # Format query
    local query=$(printf "%s+" "${args[@]}")

    # Open browser
    _browser_open "https://app.asana.com/0/search?q=${query%?}&sort=creation_time&searched_type=task${me_flag}${status_flag}"
}

# Python venv
# TODO: add args for other txt?
function venv () {
    t INFO "Checking for uv installation.."
    # Check if 'uv' command exists
    if command -v uv &> /dev/null
    then
        # --- UV MODE ---
        t INFO "uv found. Using uv for fast environment setup."

        # 1. Remove environment
        rm -rf venv
        t INFO "Old environment removed."

        # 2. Create and activate base environment
        uv venv venv
        source venv/bin/activate
        t OK "Virtual environment created and activated."

        # 3. Conditional install for main requirements.txt
        if [ -f requirements.txt ]; then
            uv pip install -r requirements.txt
            t SUCCESS "Installed main requirements.txt"
        else
            t INFO "requirements.txt not found.."
        fi

        # 4. Conditional install for test requirements-test.txt
        if [ -f requirements-test.txt ]; then
            uv pip install -r requirements-test.txt
            t INFO "Installed test requirements-test.txt"
        else
            t INFO "requirements-test.txt not found.."
        fi
    else
        # --- FALLBACK MODE (Standard VENV + PIP) ---
        t WARNING "uv not found. Falling back to python -m venv and pip."

        # 1. Remove environment
        rm -rf venv
        t INFO "Old environment removed."

        # 2. Create and activate base environment using standard venv
        python -m venv venv
        source venv/bin/activate
        t OK "Virtual environment created and activated."

        # 3. Conditional sync for main requirements.txt
        if [ -f requirements.txt ]; then
            pip install -r requirements.txt
            t OK "Installed main requirements.txt"
        else
            t WARNING "requirements.txt not found, skipping main install."
        fi

        # 4. Conditional sync for test requirements-test.txt
        if [ -f requirements-test.txt ]; then
            pip install -r requirements-test.txt
            t OK "Installed test requirements-test.txt"
        else
            t WARNING "requirements-test.txt not found, skipping test install."
        fi
    fi

    t INFO "Python executable AFTER VENV activation:"
    which python
    t SUCCESS "Setup complete. Environment is active."
}

# github related functions

# Checkout via selecting from a menu
function gco() {
    local branch=$1

    if [ -z "$branch" ]; then

        printf "${HDR_F}==========================================${NC}\n"
        printf "    ${HDR_F}git checkout b -- Choose an Option${NC}    \n"
        printf "${HDR_F}==========================================${NC}\n"
        local width=$(tput cols)
        # local width=$(($(tput cols) - 5))
        local target_width=$((width + 6))

        # Get raw and colored branch lists
        mapfile -t branches < <(git --no-pager branch --format="%(refname:short)")

        # Use --color=always to keep your pink/green hex colors
        # 'git -p' or 'git --no-pager' BEFORE 'branch'
        # truncate the line based on terminal width with 'cut'
        # Note: the subtraction (-3) accounts for the "[1]" prefix space
        # mapfile -t colored_branches < <(git --no-pager branch -vv --color=always | sed 's/^[ *]*//' | cut -c 1-$((width - 2)))
        mapfile -t colored_branches < <(git --no-pager branch -vv --color=always | sed 's/^[ *]*//')

        # Display the menu
        # echo -e "${H}Select a branch to checkout (or type 'x' to exit):${NC}"
        for i in "${!colored_branches[@]}"; do
            # printf "${SEL_F}[%s] ${NC}%s\n" "$((i+1))" "${colored_branches[$i]}"
            printf "${SEL_F}[%s] ${NC}%.${target_width}s\n" "$((i+1))" "${colored_branches[$i]}"
        done
        echo "${SEL_F}[n] Create new branch${NC}"
        echo "${BOLD}${RED}[x] Exit${NC}"
        printf "${BOLD}${WHITE}==========================================${NC}\n"

        # Prompt for selection
        read -p "Checkout branch #: " choice

        # Handle 'n' for New Branch
        if [[ "$choice" == "n" ]]; then
            read -p "Enter new branch name: " new_branch
            if [[ -n "$new_branch" ]]; then
                git checkout -b "$new_branch"
                t OK "'$new_branch' created.."
            else
                echo -e "${ERR}Branch name cannot be empty.${NC}"
            fi
            t OK "Switching to '$new_branch'.."
            return 0
        fi

        # Handle 'x' for Exit
        if [[ "$choice" == "x" ]]; then
            return 0
        fi

        # Handle numerical selection
        if [[ "$choice" =~ ^[0-9]+$ ]] && [[ "$choice" -gt 0 && "$choice" -le "${#branches[@]}" ]]; then
            selected="${branches[$((choice-1))]}"

            # if command -v pbcopy >/dev/null; then
            #     echo -n "$selected" | pbcopy
            # elif command -v clip.exe >/dev/null; then
            #     echo -n "$selected" | clip.exe
            # elif command -v xclip >/dev/null; then
            #     echo -n "$selected" | xclip -sel clip
            # fi

            # echo -e "${OK}✓ Copied '$selected' to clipboard!${NC}"
            t OK "Switching to '$selected'.."
            git checkout "$selected"
        else
            t ERR "Invalid selection."
        fi
    else
        if git checkout "$branch" 2>/dev/null; then
            t SUCCESS "Switched to existing branch ${H2}$branch${NC}"
        else
            if git checkout -b "$branch"; then
                t SUCCESS "Created and switched to ${H2}$branch${NC}"
            else
                t ERROR "Failed to create branch ${H2}$branch${NC}"
            fi
        fi
    fi
}

# removing in favogiven branch with confirmation
# function gco() {
#     local branch=$1
#     if [ -z "$branch" ]; then
#         t "Usage: gco <branch_name>"
#         return 1
#     fi
#     if git checkout "$branch"; then
#         t SUCCESS "Switched to branch ${H2}$branch${NC}"
#     else
#         t ERROR "Could not find branch ${H2}$branch${NC}"
#     fi
# }

# Checkout to a branch, create if it doesn't exist
function gcob() {
    local branch=$1
    if [ -z "$branch" ]; then
        t "Usage: gcob <branch_name>"
        return 1
    fi

    if git checkout "$branch" 2>/dev/null; then
        t SUCCESS "Switched to existing branch ${H2}$branch${NC}"
    else
        if git checkout -b "$branch"; then
            t SUCCESS "Created and switched to ${H2}$branch${NC}"
        else
            t ERROR "Failed to create branch ${H2}$branch${NC}"
        fi
    fi
}

function gpull() {
    local branch=$(git rev-parse --abbrev-ref HEAD)
    t INFO "Pulling ${H2}${branch}${NC}.."
    git pull origin "$branch" --prune
}

function gpush() {
    local branch=$(git rev-parse --abbrev-ref HEAD)
    t INFO "Pushing ${H2}${branch}${NC} to origin.."
    git push -u origin "$branch"
}

# Rename git branch
function grn() {
    local old_branch=$1
    local new_branch=$2

    if [[ "$old_branch" == "main" || "$old_branch" == "master" ]]; then
        t ERROR "Refusing to rename core branch: ${H}$old_branch${NC}"
        return 1
    fi

    if [ -z "$old_branch" ] || [ -z "$new_branch" ]; then
        t "Usage: grn <old_branch_name> <new_branch_name>"
        return 1
    fi

    if git branch -m "$old_branch" "$new_branch"; then
        t SUCCESS "Locally renamed ${H}$old_branch${NC} -> ${H2}$new_branch${NC}"

        t INFO "Syncing with origin.."
        git push origin "$new_branch"
        git push origin --delete "$old_branch"

        t SUCCESS "Origin sync complete."
    else
        t ERROR "Rename failed. Ensure branch names are correct."
    fi
}

# azure related functions
# Clear the Azure CLI cache
 function azr() {
    AZ_HTTP_CACHE_BIN="$HOME/.azure/msal_http_cache.bin"
    if [ -f $AZ_HTTP_CACHE_BIN ]; then
        t WARNING "Deleting.."
        sudo rm $HOME/.azure/msal_http_cache.bin
    else
        t "Nothing to delete."
    fi
 }

# Print current Azure DevOps iteration details and tasks assigned to the user
function print_azure_status() {
    if [[ $# -lt 4 ]]; then
        echo "Usage: print_current_iteration <AZURE_ORG> <AZURE_PROJECT> <AZURE_TEAM> <AZURE_DEVOPS_PAT>"
        return 1
    fi

    local AZURE_ORG="$1"
    local AZURE_PROJECT="$2"
    local AZURE_TEAM="$3"
    local AZURE_DEVOPS_PAT="$4"

    # Get current iteration path
    local ITERATION_API="https://dev.azure.com/$AZURE_ORG/$AZURE_PROJECT/$AZURE_TEAM/_apis/work/teamsettings/iterations?\$timeframe=current&api-version=7.0"
    local ITERATION_PATH
    ITERATION_PATH=$(curl -s -u ":$AZURE_DEVOPS_PAT" "$ITERATION_API" | jq -r '.value[0].path')
    if [[ -z "$ITERATION_PATH" || "$ITERATION_PATH" == "null" ]]; then
        echo "Could not determine current sprint/iteration."
        return 1
    fi

    # Get current iteration info
    local ITERATION_INFO
    ITERATION_INFO=$(curl -s -u ":$AZURE_DEVOPS_PAT" "$ITERATION_API" | jq '.value[0]')
    local ITERATION_NAME
    ITERATION_NAME=$(echo "$ITERATION_INFO" | jq -r '.name')
    local ITERATION_START
    ITERATION_START=$(echo "$ITERATION_INFO" | jq -r '.attributes.startDate' | cut -d'T' -f1)
    local ITERATION_END
    ITERATION_END=$(echo "$ITERATION_INFO" | jq -r '.attributes.finishDate')

    # Remove trailing Z if present (macOS date doesn't like it)
    local ITERATION_END_CLEAN=${ITERATION_END%Z}

    if date -j -f "%Y-%m-%dT%H:%M:%S" "$ITERATION_END_CLEAN" +%s >/dev/null 2>&1; then
        END=$(date -j -f "%Y-%m-%dT%H:%M:%S" "$ITERATION_END_CLEAN" +%s)
    else
        END=$(date -d "$ITERATION_END" +%s)
    fi

    # Calculate time remaining
    local NOW
    NOW=$(date +%s)
    local SECS_LEFT=$((END - NOW))
    local TIME_REMAINING
    if (( SECS_LEFT > 0 )); then
        local DAYS=$(( SECS_LEFT / 86400 ))
        local HOURS=$(( (SECS_LEFT % 86400) / 3600 ))
        local MINS=$(( (SECS_LEFT % 3600) / 60 ))

        TIME_REMAINING="Time remaining: ${KEY_F}${DAYS}${NC} days and ${KEY_F}${HOURS}${NC} hours ${KEY_F}${MINS}${NC} minutes"
    else
        TIME_REMAINING="Time remaining: Ended"
    fi

    # Print header with time remaining
    local ITERATION_END_DATE="${ITERATION_END%%T*}"

    echo -e "${BOLD}${CYAN}Current Twork Iteration: $ITERATION_NAME ($ITERATION_START → $ITERATION_END_DATE)${NC}"
    echo "$TIME_REMAINING"

    # Query all tasks/chores assigned to you in current iteration
    local WIQL="SELECT [System.Id], [System.Title], [System.WorkItemType], [System.Parent], [System.State] FROM WorkItems WHERE [System.IterationPath] = '$ITERATION_PATH' AND [System.AssignedTo] = @Me AND [System.WorkItemType] IN ('Task', 'Chore')"
    local WIQL_JSON
    WIQL_JSON=$(jq -n --arg q "$WIQL" '{query: $q}')
    local WIQL_API="https://dev.azure.com/$AZURE_ORG/$AZURE_PROJECT/_apis/wit/wiql?api-version=7.0"
    local WIQL_RESPONSE
    WIQL_RESPONSE=$(curl -s -u ":$AZURE_DEVOPS_PAT" -H "Content-Type: application/json" -d "$WIQL_JSON" "$WIQL_API")

    local TASK_IDS
    TASK_IDS=$(echo "$WIQL_RESPONSE" | jq -r '.workItems[]?.id' | paste -sd, -)

    if [[ -z "$TASK_IDS" ]]; then
        t WARNING "No tasks or chores found for you in the current sprint."
        return 0
    fi

    # Get details for all tasks/chores
    local DETAILS_API="https://dev.azure.com/$AZURE_ORG/$AZURE_PROJECT/_apis/wit/workitems?ids=$TASK_IDS&fields=System.Id,System.Title,System.WorkItemType,System.Parent,System.State&api-version=7.0"
    local TASKS_JSON
    TASKS_JSON=$(curl -s -u ":$AZURE_DEVOPS_PAT" "$DETAILS_API")

    # Collect unique parent IDs
    local PARENT_IDS
    PARENT_IDS=$(echo "$TASKS_JSON" | jq -r '.value[] | .fields."System.Parent"? ' | sort -u | paste -sd, -)

    declare -A PARENTS

    # Build associative array: id -> "type|state|title"
    if [[ -n "$PARENT_IDS" ]]; then
        local PARENT_API="https://dev.azure.com/$AZURE_ORG/$AZURE_PROJECT/_apis/wit/workitems?ids=$PARENT_IDS&fields=System.Id,System.Title,System.WorkItemType,System.State&api-version=7.0"
        local PARENTS_JSON
        PARENTS_JSON=$(curl -s -u ":$AZURE_DEVOPS_PAT" "$PARENT_API")
        while IFS='|' read -r id type state title; do
            PARENTS["$id"]="$type|$state|$title"
        done < <(echo "$PARENTS_JSON" | jq -r '.value[] | "\(.fields."System.Id")|\(.fields."System.WorkItemType")|\(.fields."System.State")|\(.fields."System.Title" | gsub("[\n\r]"; " "))"')
    fi

    for pid in $(echo "$PARENT_IDS" | tr ',' ' '); do
        [[ -z "$pid" ]] && continue
        IFS='|' read -r ptype pstate ptitle <<< "${PARENTS[$pid]}"
        pcolor=$(status_colour "$pstate")
        short_title=$(truncate_text "$ptitle" 42)
        printf "${BOLD}  -- %s %s [%b%s%b${BOLD}]: %s${NC}\n" "$pid" "$ptype" "$pcolor" "$pstate" "$NC" "$short_title"
        echo "$TASKS_JSON" | jq -r --arg pid "$pid" '
            .value[] | select(.fields."System.Parent" == ($pid|tonumber)) |
            "\(.fields."System.Id")|\(.fields."System.WorkItemType")|\(.fields."System.State")|\(.fields."System.Title")"' |
        while IFS='|' read -r cid ctype cstate ctitle; do
            ccolor=$(status_colour "$cstate")
            cshort_title=$(truncate_text "$ctitle" 42)
            printf -- "   * ${HDR_F}%s${NC} %s [%b%s%b]: %s\n" "$cid" "$ctype" "$ccolor" "$cstate" "$NC" "$cshort_title"
        done
    done

    # Orphan tasks/chores
    echo "$TASKS_JSON" | jq -r '
        .value[] | select(.fields."System.Parent" == null) |
        "\(.fields."System.Id")|\(.fields."System.WorkItemType")|\(.fields."System.State")|\(.fields."System.Title")"' |
    while IFS='|' read -r cid ctype cstate ctitle; do
        ccolor=$(status_colour "$cstate")
        cshort_title=$(truncate_text "$ctitle" 42)
        printf "${HDR_F}%s${NC} %s [%b%s%b]: %s\n" "$cid" "$ctype" "$ccolor" "$cstate" "$NC" "$cshort_title"
    done
}


 # Print current Asana project details and tasks assigned to the user
function print_asana_status() {
    if [[ $# -lt 2 ]]; then
        echo "Usage: print_asana_status <ASANA_PROJECT_GID> <ASANA_PAT>"
        return 1
    fi

    local ASANA_PROJECT_GID="$1"
    local ASANA_PAT="$2"
    local AUTH_HDR="Authorization: Bearer $ASANA_PAT"

    # Get Project/Iteration Details
    local PROJECT_API="https://app.asana.com/api/1.0/projects/$ASANA_PROJECT_GID"
    local PROJECT_JSON=$(curl -s -H "$AUTH_HDR" "$PROJECT_API")
    local PROJECT_NAME=$(echo "$PROJECT_JSON" | jq -r '.data.name // "Unknown Project"')
    local DUE_ON=$(echo "$PROJECT_JSON" | jq -r '.data.due_on')

    # Calculate Time Remaining (Handling empty due dates)
    local TIME_REMAINING="TIME REMAINING: ENDED"
    if [[ "$DUE_ON" != "null" && -n "$DUE_ON" ]]; then
        local END=$(date -d "$DUE_ON" +%s 2>/dev/null || date -j -f "%Y-%m-%d" "$DUE_ON" +%s)
        local NOW=$(date +%s)
        local SECS_LEFT=$((END - NOW))
        if (( SECS_LEFT > 0 )); then
            local DAYS=$(( SECS_LEFT / 86400 ))
            TIME_REMAINING="TIME REMAINING: ${KEY_F}${DAYS}${NC} DAYS"
        fi
    fi

    # Print Header (Uppercase to match your previous style)
    local DISPLAY_DATE=$(echo "$DUE_ON" | tr '[:lower:]' '[:upper:]')
    echo -e "${H2}CURRENT ASANA PROJECT: $PROJECT_NAME (DUE: $DISPLAY_DATE)${NC}"
    echo -e "${H}${TIME_REMAINING}${NC}"
    printf "%s\n" "$br"

    # Get Your (hopefully) GID
    local ME_GID=$(curl -sS -L --stderr /dev/null -H "$AUTH_HDR" "https://app.asana.com/api/1.0/users/me" | jq -r '.data.gid')

    # Filter tasks assigned to you (pls)
    # local MY_TASKS=$(echo "$TASKS_JSON" | jq -c --arg me "$ME_GID" '.data[] | select(.assignee.gid == $me)')
    # local MY_TASKS_DATA=$(echo "$TASKS_JSON" | jq -r --arg me "$ME_GID" --arg pgid "$ASANA_PROJECT_GID" '
    local TASKS_API="https://app.asana.com/api/1.0/tasks?project=$ASANA_PROJECT_GID&opt_fields=name,completed,assignee.gid,custom_fields.name,custom_fields.display_value,custom_fields.number_value,memberships.project.name,memberships.section.name"
    # local TASKS_JSON=$(curl -s -H "$AUTH_HDR" "$TASKS_API")

    # # DEBUG check
    # if [[ $(echo "$TASKS_JSON" | jq '.data | length') -eq 0 ]]; then
    #     t ERROR "Asana returned 0 tasks for GID $ASANA_PROJECT_GID. Check if tasks are subtasks."
    #     return 1
    # fi

    # JQ Filter
    local TASKS_DATA=$(curl -s -H "$AUTH_HDR" "$TASKS_API" | jq -r --arg me "$ME_GID" '
        .data[] | select(.assignee.gid == $me) |
        ( (.custom_fields[]? | select(.name | contains("Story Points")) | .number_value) // 0 ) as $p |
        ( (.custom_fields[]? | select(.name | contains("Ticket Type")) | .display_value) // "Task" ) as $t |
        ( first(.custom_fields[]? | select(.name == "RECON") | .display_value) // "---" ) as $id |
        ( [ .memberships[]? | select(.project.name | contains("Sprint")) ] | .[0].section.name // "No Section" ) as $s |
        "\($s)|\($id)|\($p)|\($t)|\(.name)|\(.gid)"
    ')

    if [[ -z "$TASKS_DATA" ]]; then
        echo -e "${KEY_F}NO TASKS ASSIGNED TO YOU.${NC}"
        return 0
    fi

    local TOTAL_POINTS=0

    # Display
    while IFS='|' read -r r_sec r_tid r_pts r_type r_name r_gid; do
        TOTAL_POINTS=$((TOTAL_POINTS + r_pts))

        # No emojis smh my head
        local clean_section=$(echo "$r_sec" | sed 's/[^[:alnum:][:space:]]//g' | xargs)

        # Clean and trunc
        local clean_name=$(echo "$r_name" | sed -E "s/^${r_tid}[[:space:]]*[|:-]*[[:space:]]*//")
        [[ -z "$clean_name" ]] && clean_name="$r_name"

        local display_name=$(truncate_text "$clean_name" 15)
        local s_color=$(status_colour "$clean_section")
        local t_color=$(status_colour "$r_type")

        # --- OUTPUT ---
        # FML FML FML FML FML FML
        display_name=""
        title="${r_gid%|*}"
        id="${r_gid#*|}"
        title=$(echo "$title" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
        id=$(echo "$id" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
        trunct_title=$(truncate_text "$title" 32)
        # Ignore this pls

        printf "${BOLD}$s_color%-12s>${NC} %-10s${NC} $t_color%-5s (%s pts)${NC} %s[ ${BLUE}%s${NC} ] ${DIM_F}%s${NC}\n" \
            "$clean_section" "$r_tid" "$r_type" "$r_pts" "$trunct_title" "$id"

    done <<< "$TASKS_DATA"

    # Summary
    echo -e "${H2_F}TOTAL WORKLOAD: ${H_F}${TOTAL_POINTS}${H2_F} POINTS${NC}"
}
