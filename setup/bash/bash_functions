#!/usr/bin/env bash
# ===================================================================== #
# BASH FUNCTIONS
# ===================================================================== #

# ------------------------------------------
# General Helper functions
# ------------------------------------------
# helper to handle the browser opening logic
function _browser_open() {
    local url="$1"

    if [[ -n "$WSL_DISTRO_NAME" ]]; then
        # WSL: Open in Windows default browser
        powershell.exe -NoProfile -Command "Start-Process '$url'"
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        # macos: Open in default Mac browser
        open "$url"
    else
        # Standard Linux: Use xdg-open
        xdg-open "$url" 2>/dev/null
    fi
}

# helper to get color for a status
function _status_colour() {
    local status="$1"
    case "$status" in
        "To Do"|"New"|*"On Deck"*|"Story"|"Task") echo "$PINK" ;;
        "In Progress"|"Active"|*"In Progress"*|"Epic") echo "$CYAN" ;;
        "Done"|"Closed"|"Completed"|"Resolved"|*"Done"*) echo "$GREEN" ;;
        "Blocked"|*"In Review"*|"Bug"|"IT") echo "$RED" ;;
        *) echo "$WHITE" ;;
    esac
}

# helper to truncate text to a maximum length
function _truncate_text() {
    local text="$1"
    local maxlen="${2:-30}"
    if [ ${#text} -gt "$maxlen" ]; then
        echo "${text:0:$((maxlen-3))}.."
    else
        echo "$text"
    fi
}

# function to load config
function _load_config() {
    if [ -z "$DOTFILES_CONFIG_DIR" ]; then
        DOTFILES_CONFIG_DIR="$HOME/.config/dotfiles"
    fi

    if [[ ! -d "$DOTFILES_CONFIG_DIR" && ! -d "$DOTFILES_REPO_DIR" ]]; then
        echo -e "\e[31m[ ERR  ]\e[0m Configuration file not found at $DOTFILES_CONFIG_FILE" or "$DOTFILES_REPO_DIR" >&2
        return 1 2>/dev/null || exit 1
    fi

    if [[ -f "$DOTFILES_CONFIG_DIR/.init" ]]; then
        . "$DOTFILES_CONFIG_DIR/.init"
    elif [[ -f "$DOTFILES_REPO_DIR/setup/bash/init" ]]; then
        . "$DOTFILES_REPO_DIR/setup/bash/init"
    else
        echo "\e[31m[ WARN ]\e[0m Failed to load core config"
    fi

    [[ -f "$DOTFILES_CONFIG_DIR/.init" ]] && . "$DOTFILES_CONFIG_DIR/.init"
}

# helper to update or add a config/variable
function _set_config() {
    local key="$1"
    local value="$2"
    local config_file="${3:-$DOTFILES_CONFIG_FILE}"

    if [[ -z "$key" || -z "$value" ]]; then
        t ERR "Usage: _set_config <KEY> <VALUE> [CONFIG_FILE]"
        return 1
    fi

    # ensure the directory exists
    mkdir -p "$(dirname "$config_file")"
    touch "$config_file"

    if grep -q "^$key=" "$config_file"; then
        # line exists: replace it
        # using '|' as a delimiter to safely handle paths/slashes in values
        sed -i "s|^$key=.*|$key=$value|" "$config_file"
    else
        # line missing: append it
        echo "$key=$value" >> "$config_file"
    fi
}

# helper to fetch config/variable
function _get_config() {
    local var_name="$1"
    local config_file="${2:-$DOTFILES_CONFIG_FILE}"
    local value=""

    # try to get from the config_file first
    if [[ -f "$config_file" ]]; then
        value=$(grep "^${var_name}=" "$config_file" | cut -d'=' -f2- | tr -d '\r')
    fi

    # fallback to shell environment if config_file search was empty
    if [[ -z "$value" ]]; then
        # ${!var_name} is Bash indirect expansion (gets the value of the name stored in var_name)
        value="${!var_name}"
        # alternatively printenv
        # value=$(printenv "$var_name")
    fi

    if [[ -n "$value" ]]; then
        echo "$value"
        return 0
    fi
    return 1
}

# helper to fetch value from .gitconfig
function _get_git_config() {
    if [ -z "$1" ]; then
        t ERR "Error: No configuration key provided." >&2
        t ERR "Usage: _get_git_config <section.key>" >&2
        return 1
    fi

    # use git's internal engine to find the value
    # --get returns the value, or nothing (and an exit code of 1) if not found
    local value
    value=$(git config --get "$1")

    if [ $? -eq 0 ]; then
        echo "$value"
    else
        return 1
    fi
}

# ------------------------------------------
# util functions
# ------------------------------------------
# display date and time
function now() {
    echo "$(date +"%d-%m-%Y") $(date +"%T")"
}

# output standardize msg
function t() {
    # t "System started"                  # [ INFO ] System started
    # t WARNING "Disk space low"          # [ WARN ] Disk space low
    # t ERROR "Failed to connect to DB"   # [ ERR  ] Failed to connect to DB
    # t                                   # Hello world
    local severity message color label
    local timestamp=$(date +"%H:%M:%S")

    if [[ $# -eq 0 ]]; then
        echo -e "${GREEN}Hello world${NC}"
        return
    elif [[ $# -eq 1 ]]; then
        severity="INFO"
        message="$1"
    else
        severity=$(echo "$1" | tr '[:lower:]' '[:upper:]')
        message="$2"
    fi

    # define color and label mapping
    case "$severity" in
        INFO)           color="${INFO}";  label="[ INFO ]" ;;
        IMPORTANT)      color="${INFO}";  label="[ INFO ]" ;;
        WARN|WARNING)   color="${WARN}";  label="[ WARN ]" ;;
        ERR|ERROR)      color="${ERR}";   label="[ ERR  ]" ;;
        SUCCESS|OK)     color="${OK}";    label="[  OK  ]" ;;
        ALERT)          color="${ALERT}"; label="[-ALERT]" ;;
        TODO)           color="${ALERT}"; label="[ TODO ]" ;;
        DEBUG)          color="${DEBUG}"; label="[-DEBUG]" ;;
        *)              color="${BOLD}";  label="[-$severity]" ;;
    esac

    # output formatted message
    # format: [HH:MM:SS] [LABEL] Message
    echo -e "${DEBUG}${timestamp}${NC} ${color}${label}${NC} ${message}${NC}"
}

# compare and pipe to less while preserving colors
dless() {
    if command -v colordiff >/dev/null 2>&1; then
        colordiff -u "$1" "$2" | less -R
    else
        diff -u "$1" "$2" | less
    fi
}

# ceate a directory and move into it immediately
mkcd() {
    mkdir -p "$1" && cd "$1" || return
}

# automatically 'ls' after every 'cd'
cd() {
    builtin cd "$@" && ls
}

# ------------------------------------------
# reset flow: r & rr
# ------------------------------------------
# setup processes for r running dotfile install
function pre_r() {
    unset BASH_STYLE_LOADED

    if [[ "$(pwd)" == *"/dotfiles" && -d ".git" ]]; then
        IS_PROJECT_ROOT=true
        DOTFILES_REPO_DIR=$(pwd)
    else
        IS_PROJECT_ROOT=false

        # --- Start Load Configuration ---
        if [ -z "$DOTFILES_CONFIG_FILE" ]; then
            DOTFILES_CONFIG_FILE="$HOME/.config/dotfiles/.dotfile_config"
        fi

        if [ -f "$DOTFILES_CONFIG_FILE" ]; then
            source "$DOTFILES_CONFIG_FILE"
        else
            echo "[ ERR  ] Configuration file not found at $DOTFILES_CONFIG_FILE" >&2
            exit 1
        fi

        DOTFILES_CONFIG_DIR="$HOME/.config/dotfiles"
        [[ -f "$DOTFILES_CONFIG_DIR/.init" ]] && . "$DOTFILES_CONFIG_DIR/.init"
        # --- End Load Configuration ---
    fi

    echo "[ INFO ] Resetting settings.."
    if [ "$IS_PROJECT_ROOT" = false ]; then
      if [[ -n "$DOTFILES_REPO_DIR" ]]; then
        pushd $DOTFILES_REPO_DIR > /dev/null
      else
        echo "[ ERR  ] You are not in the root of the dotfile project! DOTFILES_REPO_DIR is not set. Exiting.."
        return 1
      fi
    fi
}

# post processes after dotfile install
function post_r() {
    if [ "$IS_PROJECT_ROOT" = false ]; then
      popd > /dev/null
    fi

    # DOTFILES_CONFIG_DIR="$HOME/.config/dotfiles"
    # [[ -f "$DOTFILES_CONFIG_DIR/.bash_style" ]] && . "$DOTFILES_CONFIG_DIR/.bash_style"

    # t SUCCESS "${SUCCESS}All set!${NC}"
}

# re-run dotfiles sync
r() {
    pre_r

    ./install.sh

    post_r
}

# re-run just bash sync (forced y)
rr() {
    pre_r

    FORCE_YES=1 ./install.sh bash-only

    post_r
}

# reset and pull latest from repo, then re-run just bash sync (forced y)
rrr() {
    pre_r

    clone_or_pull_dotfiles -rb

    post_r
}

# ------------------------------------------
# init special .bash_
# ------------------------------------------
# copy generic .bash_twork starter file
set-tworktt() {
    if [ -z "$DOTFILES_REPO_DIR" ]; then
		t ERROR "DOTFILES_REPO_DIR not set, check $HOME/.config/dotfiles/.dotfile_config"
        exit 1
	else
        if [ -z "$DOTFILES_CONFIG_DIR" ]; then
            DOTFILES_CONFIG_DIR="$HOME/.config/dotfiles"
        fi

		t "Generating basic tworktt file"
        TWORKTT_FILE="$DOTFILES_REPO_DIR/setup/_templates/twork-template.txt"
        if [ -f "$TWORKTT_FILE" ]; then
            cpp -q "$TWORKTT_FILE" "$DOTFILES_CONFIG_DIR/.bash_twork"
            t SUCCESS "All set! Remember to edit .bash_twork"
        else
            t Error "twork-template.txt file not found at $DOTFILES_REPO_DIR/setup/_templates" >&2
            exit 1
        fi
	fi
}

# copy generic .bash_personal starter file
set-ptt() {
    if [ -z "$DOTFILES_REPO_DIR" ]; then
		t ERROR "DOTFILES_REPO_DIR not set, check $HOME/.config/dotfiles/.dotfile_config"
        exit 1
	else
        if [ -z "$DOTFILES_CONFIG_DIR" ]; then
            DOTFILES_CONFIG_DIR="$HOME/.config/dotfiles"
        fi

		t "Generating basic personal file"
        TWORKTT_FILE="$DOTFILES_REPO_DIR/setup/_templates/personal-template.txt"
        if [ -f "$TWORKTT_FILE" ]; then
            cpp -q "$TWORKTT_FILE" "$DOTFILES_CONFIG_DIR/.bash_personal"
            t SUCCESS "All set! Remember to edit .bash_personal"
        else
            t Error "personal-template.txt file not found at $DOTFILES_REPO_DIR/setup/_templates" >&2
            exit 1
        fi
	fi
}

# ------------------------------------------
# utils
# ------------------------------------------
# extract a file
ex() {
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)   tar xvjf $1    ;;
            *.tar.gz)    tar xvzf $1    ;;
            *.bz2)       bunzip2 $1     ;;
            *.rar)       unrar x $1       ;;
            *.gz)        gunzip $1      ;;
            *.tar)       tar xvf $1     ;;
            *.tbz2)      tar xvjf $1    ;;
            *.tgz)       tar xvzf $1    ;;
            *.zip)       unzip $1       ;;
            *.Z)         uncompress $1  ;;
            *.7z)        7z x $1        ;;
            *)           t ERROR "don't know how to extract '$1'.." ;;
        esac
    else
        t ERROR "'$1' is not a valid file!"
    fi
 }

# display a PDF of a given man page
pdfman() {
    man -t $@ | pstopdf -i -o /tmp/$1.pdf && open /tmp/$1.pdf
}

# print env, use -l to only display core details
printv() {
    local show_limited=false
    local env_file=""
    local limit_vars=("BASE_URL" "ALLOWED_HOSTS" "ENFIRONMENT", "POSTGRES_HOST", "POSTGRES_DB")

    # check for -l flag
    if [[ "$1" == "-l" ]]; then
        show_limited=true
    fi

    # search for .env in current and up to two parent directories
    for dir in "." ".." "../.."; do
        if [[ -f "$dir/.env" ]]; then
        env_file="$dir/.env"
        break
        fi
    done

    if [[ -z "$env_file" ]]; then
        t "No .env file found in current or parent directories"
        return 1
    fi

    t "Found .env at: $env_file"

    if $show_limited; then
        for var in "${limit_vars[@]}"; do
        grep -E "^$var=" "$env_file"
        done
    else
        cat "$env_file"
    fi
}

# searches for text in all files in the current folder
ftext() {
	# -i case-insensitive
	# -I ignore binary files
	# -H causes filename to be printed
	# -r recursive search
	# -n causes line number to be printed
	# optional: -F treat search term as a literal, not a regular expression
	# optional: -l only print filenames and not the matching lines ex. grep -irl "$1" *
	grep -iIHrn --color=always "$1" . | less -r
}

# copy file with a progress bar
cpp() {
    local quiet=false
    local do_source=false
    local args=()

    # parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -q|--quiet)  quiet=true; shift ;;
            -s|--source) do_source=true; shift ;;
            -*)          t ERR "Unknown option: $1"; return 1 ;;
            *)           args+=("$1"); shift ;;
        esac
    done

    local src="${args[0]}"
    local dest="${args[1]}"

    if [[ -z "$src" || -z "$dest" ]]; then
        t ERR "Usage: cpp [-q] [-s] <source> <destination>"
        return 1
    fi

    # perform the copy
    rsync -ah --info=progress2 "$src" "$dest"

    # clear the rsync progress line
    printf "\033[1A\r\033[K"

    if [[ "$quiet" == false ]]; then
        t OK "Transfer of $(basename "$dest") complete."
    fi

    # handle the sourcing logic
    if [[ "$do_source" == true ]]; then
        if [[ -f "$dest" ]]; then
            source "$dest"
        else
            t ERR "Failed to source: $dest (file not found)"
            return 1
        fi
    fi
}

# find a file with a pattern in name:
ff() {
    find . -type f -iname '*'"$*"'*' -ls ;
}

# starship theme switcher
sss() {
    local config_dir="$HOME/.config"
    local target="$config_dir/starship.toml"

    # find all .toml files in ~/.config, excluding the active starship.toml
    # strip the path to just show the filenames in the menu
    local themes=($(find "$config_dir" -maxdepth 1 -name "starship.*.toml" -printf "%f\n" | sort))

    printf "${HDR_F}==========================================${NC}\n"
    printf "    ${HDR_F}Starship theme -- Choose an Option${NC}    \n"
    printf "${HDR_F}==========================================${NC}\n"

    local i=1
    for theme in "${themes[@]}"; do
        # clean up the name for the display (e.g., starship.gruvbox.toml -> gruvbox)
        local display_name=$(echo "$theme" | sed 's/starship.\(.*\).toml/\1/')
        printf "${SEL_F}[$i]${NC} Load ${display_name^} Theme ${SUB_F}($theme)${NC}\n"
        ((i++))
    done
    printf "${BOLD}${RED}[x]${NC} Exit\n"
    printf "${BOLD}${WHITE}==========================================${NC}\n"

    echo -ne "\n${SEL_F}Switch Starship theme:${NC} "
    read -r opt

    if [[ "$opt" == "x" || "$opt" == "q" ]]; then
        t "No changes made."
        return 0
    elif [[ "$opt" -gt 0 && "$opt" -le ${#themes[@]} ]]; then
        local selected_theme="${themes[$((opt-1))]}"

        # backup and Swap // Just swap no backup currently
        # [[ -f "$target" ]] && cp "$target" "$target.bak"
        cp "$config_dir/$selected_theme" "$target"

        t OK "${SEL_F}[âœ“]${NC} Switched to ${selected_theme}"
    else
        t ERR "${SEL_F}[!]${NC} Invalid selection."
        return 1
    fi
}

# ------------------------------------------
# searches/open link functions
# ------------------------------------------
# duckduckgo search
ddg() {
    if [[ -z "$1" ]]; then
        t ERR "Usage: ddg <query>"
        return 1
    fi
    local query=$(printf "%s+" "$@")
    _browser_open "https://duckduckgo.com/?q=${query%?}"
}

# dictionary search (Merriam-Webster)
dict() {
    [[ -z "$1" ]] && { t ERR "Usage: dict <word>"; return 1; }
    _browser_open "https://www.merriam-webster.com/dictionary/$1"
}

# urban dictionary (Slang)
urban() {
    [[ -z "$1" ]] && { t ERR "Usage: urban <query>"; return 1; }
    local query=$(printf "%s+" "$@")
    _browser_open "https://www.urbandictionary.com/define.php?term=${query%?}"
}

# youtube search
yt() {
    if [[ -z "$1" ]]; then
        t ERR "Usage: yt <query>"
        return 1
    fi
    local query=$(printf "%s+" "$@")
    _browser_open "https://www.youtube.com/results?search_query=${query%?}"
}

# google search
gg() {
    if [[ -z "$1" ]]; then
        t ERR "Usage: gg <query>"
        return 1
    fi
    local query=$(printf "%s+" "$@")
    _browser_open "https://www.google.com/search?q=${query%?}"
}

# gitHub search
ghs() {
    local gh_ins="https://github.com"
    local type_flag="&type=repositories"
    local args=()
    local prs=""
    local repos=""
    local gh_username=""

    # parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --me)
                local config_gh_username=$(_get_config "GITHUB_USERNAME")
                if [[ -n "$config_gh_username" ]]; then
                    gh_username="$config_gh_username"
                else
                    local gitconfig_gh_username=$(_get_git_config user.name)
                    if [[ -n "$gitconfig_gh_username" ]]; then
                        gh_username="$gitconfig_gh_username"
                    else
                        t WARN "--me flag given but GITHUB_USERNAME is not set in env or in .gitconfig"
                        return 1
                    fi
                fi
                shift
                ;;
            --twork)
                local twork_gh_ins=$(_get_config "TWORK_GH_INSTACE")
                if [[ -n "$twork_gh_ins" ]]; then
                    gh_ins="$twork_gh_ins"
                else
                    t ERR "--twork flag given but TWORK_GH_INSTACE is not set"
                    return 1
                fi
                shift
                ;;
            --lang)
                case "${2,,}" in # ,, converts to lowercase for easier matching
                    py|python)       lang_query="+language:python" ;;
                    js|javascript)   lang_query="+language:javascript" ;;
                    ts|typescript)   lang_query="+language:typescript" ;;
                    rb|ruby)         lang_query="+language:ruby" ;;
                    go|golang)       lang_query="+language:go" ;;
                    rs|rust)         lang_query="+language:rust" ;;
                    cpp|c++)         lang_query="+language:cpp" ;;
                    cs|csharp|c#)    lang_query="+language:csharp" ;;
                    *)               lang_query="+language:$2" ;; # Fallback for literals
                esac
                shift 2 ;;
            --type)
                # Map the user input to GitHub's type param
                case "$2" in
                    c|code) type_flag="&type=code" ;;
                    r|repo|repos|repositories) type_flag="&type=repositories" ;;
                    i|issue|issues)   type_flag="&type=issues" ;;
                    pr|prs|pullrequests)   type_flag="&type=pullrequests" ;;
                    u|user|users)   type_flag="&type=users" ;;
                    *) t ERR "Type must be: code, repositories, issues, pullrequests, or users" && return 1 ;;
                esac
                shift 2
                ;;
            --pr|--prs)
                # Map the user input to GitHub's type param
                case "$2" in
                    nr) prs="pulls?q=is%3Aopen+label%3A%22needs+review%22" && shift ;;
                    *) prs="pulls?" ;;
                esac
                shift
                ;;
            --repo|--repos)
                repos=repos
                shift
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done

    # validation
    if [[ -z "$prs" && -z "$repos" && ${#args[@]} -eq 0 ]]; then
        t ERR "Usage: ghs [--me] [--twork] ([--type <type>] [--lang <lang>] <query> | --prs [nr] | --repos)"
        return 1
    fi

    # standard search logic
    if [[ -z "$prs" && -z "$repos" ]]; then
        local query=$(printf "%s+" "${args[@]}")
        _browser_open "${gh_ins}/search?q=${query%?}${lang_query}${type_flag}"
    fi

    # pr search logic
    if [[ -n "$prs" ]]; then
        local pr_query=""
        if [[ -n "$gh_username" ]]; then
            # If prs already has a query (like 'nr'), append to it.
            # Otherwise, start the query.
            if [[ "$prs" == *"q="* ]]; then
                pr_query="+author%3A${gh_username}"
            else
                pr_query="q=is%3Aopen+author%3A${gh_username}"
            fi
        fi
        _browser_open "${gh_ins}/${prs}${pr_query}"
    fi

    # repos search logic
    if [[ -n "$repos" ]]; then
        if [[ -n "$gh_username" ]]; then
            # opens your specific profile's repo tab
            _browser_open "${gh_ins}/${gh_username}?tab=repositories"
        else
            # _browser_open "${gh_ins}/${repos}"
            _browser_open "${gh_ins}/trending"
        fi
    fi
}

# asana search
asa() {
    local me_flag=""
    local collab_param=""
    local status_param=""
    local args=()

    # parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --me)
                local my_id=$(_get_config "ASANA_ME_ID")
                if [[ -n "$my_id" ]]; then
                    me_flag="&assignees.ids=${my_id}"
                else
                    # fallback if variable is missing from the file
                    t WARN "--me flag given but ASANA_ME_ID is not set, defaulting to 'me'"
                    me_flag="&assignees.ids=me"
                fi
                shift
                ;;
            --user)
                # convert input to uppercase (e.g., someguy -> SOMEGUY)
                local user_name="${2^^}"
                local user_id=$(_get_config "ASANA_${user_name}_ID")

                if [[ -n "$user_id" ]]; then
                    me_flag="&assignees.ids=${user_id}"
                else
                    t ERR "No ID found for ASANA_${user_name}_ID in config."
                    return 1
                fi
                shift 2
                ;;
            --collab)
                # convert input to uppercase (e.g., someguy -> SOMEGUY)
                local user_name_collab="${2^^}"
                local user_id_collab=$(_get_config "ASANA_${user_name_collab}_ID")

                if [[ -n "$user_id_collab" ]]; then
                    collab_param="&collaborators.ids=${user_id_collab}"
                else
                    t ERR "No ID found for ASANA_${user_name_collab}_ID in config."
                    return 1
                fi
                shift 2
                ;;
            --status)
                # map the user input to asana's url parameters
                case "$2" in
                    completed|complete) status_param="&completion=complete" ;;
                    incomplete) status_param="&completion=incomplete" ;;
                    deleted|delete)   status_param="&deleted=true" ;;
                    *) t ERR "Status must be: incomplete, completed, or deleted" && return 1 ;;
                esac
                shift 2
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done

    # check if we have a query
    if [[ ${#args[@]} -eq 0 && -z "$status_param" && -z "$gh_username" ]]; then
        t ERR "Usage: asa [--me] [--user <USER>] [--collab <USER>] [--status <incomplete|completed|deleted>] [query]"
        return 1
    fi

    # format query
    local query=$(printf "%s+" "${args[@]}")

    # open browser
    _browser_open "https://app.asana.com/0/search?q=${query%?}&sort=last_modified&searched_type=task${me_flag}${collab_param}${status_param}"
}

# ------------------------------------------
# git functions
# ------------------------------------------
# function to clone or pull dotfiles repository
function clone_or_pull_dotfiles() {
    local reset_bash=false

    # check for -rb flag
    if [[ "$1" == "-rb" ]]; then
        reset_bash=true
    fi

    t "Managing dotfiles repository.."
    if [ -d "$DOTFILES_REPO_DIR/.git" ]; then
        t "${SUB_F}dotfiles${NC} directory '$DOTFILES_REPO_DIR' already exists."
        # navigate to the dotfiles directory
        cd "$DOTFILES_REPO_DIR" || { t Error "Failed to change directory to $DOTFILES_REPO_DIR. Aborting."; exit 1; }
        printf "\033[1A\r\033[K"

        local stashed_changes=false
        # check if there are any uncommitted changes (staged or unstaged)
        if [[ $(git status --porcelain) ]]; then
            t WARN "Uncommitted changes detected. Stashing them temporarily.."
            # use 'git stash push' for modern git, 'save' is deprecated but works
            if git stash push -m "Temporary stash by dotfiles script before pull"; then
                stashed_changes=true
                t OK "Changes stashed successfully."
            else
                t Error "Failed to stash uncommitted changes. Aborting pull."
                # return to home directory before exiting on error
                cd "$HOME" || { t Error "Failed to return to home directory after stash error."; }
                exit 1
            fi
        fi

        t "Pulling latest changes from '$DOTFILES_REPO'.."
        # ensure we pull from the correct branch, or just 'git pull' if upstream is set
        local current_branch=$(git rev-parse --abbrev-ref HEAD)
        if ! git pull origin "$current_branch" &> /dev/null; then
            t Error "Failed to pull ${ERR}dotfiles${NC} from '$DOTFILES_REPO'. Please check your network or repository access."
            # attempt to reapply stash even if pull failed, so user can resolve
            if $stashed_changes; then
                t WARN "Attempting to reapply stashed changes after pull failure.."
                git stash pop || t Warning "Failed to pop stash. You may have conflicts to resolve manually."
            fi
            # return to home directory before exiting on error
            cd "$HOME" || { t Error "Failed to return to home directory after pull error."; }
            printf "\033[1A\r\033[K"
            exit 1
        fi

        if $reset_bash; then
            FORCE_YES=1 ./install.sh bash-only
        fi

        if $stashed_changes; then
            t "Applying stashed changes.."
            # git stash pop will fail if there are conflicts, but the user requested it.
            # we'll report if it fails.
            if git stash pop &> /dev/null; then
                t OK "Stashed changes applied successfully."
            else
                t Warning "Failed to pop stash. You may have conflicts to resolve manually in '$DOTFILES_REPO_DIR'."
            fi
        fi

    else # repository does not exist, clone it
        t OK "Cloning ${SUB_F}dotfiles${NC} repository '$DOTFILES_REPO' to '$DOTFILES_REPO_DIR'.."
        mkdir -p "$DOTFILES_REPO_DIR" # ensure parent directory exists
        if ! git clone "$DOTFILES_REPO" "$DOTFILES_REPO_DIR"; then
            t Error "Failed to clone ${ERR}dotfiles from${NC} '$DOTFILES_REPO'. Please check the URL and your network."
            exit 1
        fi
    fi
    # always return to home directory at the end of the function
    cd "$HOME" || { t Error "Failed to return to home directory."; exit 1; }
    printf "\033[1A\r\033[K"
}

# checkout via selecting from a menu
function gco() {
    local branch=$1

    if [ -z "$branch" ]; then

        printf "${HDR_F}==========================================${NC}\n"
        printf "    ${HDR_F}git checkout b -- Choose an Option${NC}    \n"
        printf "${HDR_F}==========================================${NC}\n"
        local width=$(tput cols)
        # local width=$(($(tput cols) - 5))
        local target_width=$((width + 6))

        # get raw and colored branch lists
        mapfile -t branches < <(git --no-pager branch --format="%(refname:short)")

        # use --color=always to keep your pink/green hex colors
        # 'git -p' or 'git --no-pager' BEFORE 'branch'
        # truncate the line based on terminal width with 'cut'
        # Note: the subtraction (-3) accounts for the "[1]" prefix space
        # mapfile -t colored_branches < <(git --no-pager branch -vv --color=always | sed 's/^[ *]*//' | cut -c 1-$((width - 2)))
        mapfile -t colored_branches < <(git --no-pager branch -vv --color=always | sed 's/^[ *]*//')

        # display the menu
        # echo -e "${H}Select a branch to checkout (or type 'x' to exit):${NC}"
        for i in "${!colored_branches[@]}"; do
            # printf "${SEL_F}[%s] ${NC}%s\n" "$((i+1))" "${colored_branches[$i]}"
            printf "${SEL_F}[%s] ${NC}%.${target_width}s\n" "$((i+1))" "${colored_branches[$i]}"
        done
        echo "${SEL_F}[n] Create new branch${NC}"
        echo "${BOLD}${RED}[x] Exit${NC}"
        printf "${BOLD}${WHITE}==========================================${NC}\n"

        # prompt for selection
        read -p "Checkout branch #: " choice

        # handle 'n' for New Branch
        if [[ "$choice" == "n" ]]; then
            read -p "Enter new branch name: " new_branch
            if [[ -n "$new_branch" ]]; then
                git checkout -b "$new_branch"
                t OK "'$new_branch' created.."
            else
                echo -e "${ERR}Branch name cannot be empty.${NC}"
            fi
            t OK "Switching to '$new_branch'.."
            return 0
        fi

        # handle 'x' for Exit
        if [[ "$choice" == "x" || "$choice" == "q" ]]; then
            return 0
        fi

        # handle numerical selection
        if [[ "$choice" =~ ^[0-9]+$ ]] && [[ "$choice" -gt 0 && "$choice" -le "${#branches[@]}" ]]; then
            selected="${branches[$((choice-1))]}"

            # if command -v pbcopy >/dev/null; then
            #     echo -n "$selected" | pbcopy
            # elif command -v clip.exe >/dev/null; then
            #     echo -n "$selected" | clip.exe
            # elif command -v xclip >/dev/null; then
            #     echo -n "$selected" | xclip -sel clip
            # fi

            # echo -e "${OK}âœ“ Copied '$selected' to clipboard!${NC}"
            t OK "Switching to '$selected'.."
            git checkout "$selected"
        else
            t ERR "Invalid selection."
        fi
    else
        if git checkout "$branch" 2>/dev/null; then
            t SUCCESS "Switched to existing branch ${H2}$branch${NC}"
        else
            if git checkout -b "$branch"; then
                t SUCCESS "Created and switched to ${H2}$branch${NC}"
            else
                t ERROR "Failed to create branch ${H2}$branch${NC}"
            fi
        fi
    fi
}

# removing in favour of new flow above
# function gco() {
#     local branch=$1
#     if [ -z "$branch" ]; then
#         t "Usage: gco <branch_name>"
#         return 1
#     fi
#     if git checkout "$branch"; then
#         t SUCCESS "Switched to branch ${H2}$branch${NC}"
#     else
#         t ERROR "Could not find branch ${H2}$branch${NC}"
#     fi
# }

# checkout to a branch, create if it doesn't exist
function gcob() {
    local branch=$1
    if [ -z "$branch" ]; then
        t "Usage: gcob <branch_name>"
        return 1
    fi

    if git checkout "$branch" 2>/dev/null; then
        t SUCCESS "Switched to existing branch ${H2}$branch${NC}"
    else
        if git checkout -b "$branch"; then
            t SUCCESS "Created and switched to ${H2}$branch${NC}"
        else
            t ERROR "Failed to create branch ${H2}$branch${NC}"
        fi
    fi
}

# git pull
function gpull() {
    local branch=$(git rev-parse --abbrev-ref HEAD)
    t INFO "Pulling ${H2}${branch}${NC}.."
    git pull origin "$branch" --prune
}

# git push
function gpush() {
    local branch=$(git rev-parse --abbrev-ref HEAD)
    t INFO "Pushing ${H2}${branch}${NC} to origin.."
    git push -u origin "$branch"
}

# rename git branch
function grn() {
    local old_branch=$1
    local new_branch=$2

    if [[ "$old_branch" == "main" || "$old_branch" == "master" ]]; then
        t ERROR "Refusing to rename core branch: ${H}$old_branch${NC}"
        return 1
    fi

    if [ -z "$old_branch" ] || [ -z "$new_branch" ]; then
        t "Usage: grn <old_branch_name> <new_branch_name>"
        return 1
    fi

    if git branch -m "$old_branch" "$new_branch"; then
        t SUCCESS "Locally renamed ${H}$old_branch${NC} -> ${H2}$new_branch${NC}"

        t INFO "Syncing with origin.."
        git push origin "$new_branch"
        git push origin --delete "$old_branch"

        t SUCCESS "Origin sync complete."
    else
        t ERROR "Rename failed. Ensure branch names are correct."
    fi
}

# ------------------------------------------
# azure related functions
# ------------------------------------------
# clear the azure cli cache
 function azr() {
    AZ_HTTP_CACHE_BIN="$HOME/.azure/msal_http_cache.bin"
    if [ -f $AZ_HTTP_CACHE_BIN ]; then
        t WARNING "Deleting.."
        sudo rm $HOME/.azure/msal_http_cache.bin
    else
        t "Nothing to delete."
    fi
 }

# print current azure devops iteration details and tasks assigned to the user
function print_azure_status() {
    if [[ $# -lt 4 ]]; then
        echo "Usage: print_current_iteration <AZURE_ORG> <AZURE_PROJECT> <AZURE_TEAM> <AZURE_DEVOPS_PAT>"
        return 1
    fi

    local AZURE_ORG="$1"
    local AZURE_PROJECT="$2"
    local AZURE_TEAM="$3"
    local AZURE_DEVOPS_PAT="$4"

    # get current iteration path
    local ITERATION_API="https://dev.azure.com/$AZURE_ORG/$AZURE_PROJECT/$AZURE_TEAM/_apis/work/teamsettings/iterations?\$timeframe=current&api-version=7.0"
    local ITERATION_PATH
    ITERATION_PATH=$(curl -s -u ":$AZURE_DEVOPS_PAT" "$ITERATION_API" | jq -r '.value[0].path')
    if [[ -z "$ITERATION_PATH" || "$ITERATION_PATH" == "null" ]]; then
        echo "Could not determine current sprint/iteration."
        return 1
    fi

    # get current iteration info
    local ITERATION_INFO
    ITERATION_INFO=$(curl -s -u ":$AZURE_DEVOPS_PAT" "$ITERATION_API" | jq '.value[0]')
    local ITERATION_NAME
    ITERATION_NAME=$(echo "$ITERATION_INFO" | jq -r '.name')
    local ITERATION_START
    ITERATION_START=$(echo "$ITERATION_INFO" | jq -r '.attributes.startDate' | cut -d'T' -f1)
    local ITERATION_END
    ITERATION_END=$(echo "$ITERATION_INFO" | jq -r '.attributes.finishDate')

    # remove trailing Z if present (macos date doesn't like it)
    local ITERATION_END_CLEAN=${ITERATION_END%Z}

    if date -j -f "%Y-%m-%dT%H:%M:%S" "$ITERATION_END_CLEAN" +%s >/dev/null 2>&1; then
        END=$(date -j -f "%Y-%m-%dT%H:%M:%S" "$ITERATION_END_CLEAN" +%s)
    else
        END=$(date -d "$ITERATION_END" +%s)
    fi

    # calculate time remaining
    local NOW
    NOW=$(date +%s)
    local SECS_LEFT=$((END - NOW))
    local TIME_REMAINING
    if (( SECS_LEFT > 0 )); then
        local DAYS=$(( SECS_LEFT / 86400 ))
        local HOURS=$(( (SECS_LEFT % 86400) / 3600 ))
        local MINS=$(( (SECS_LEFT % 3600) / 60 ))

        TIME_REMAINING="Time remaining: ${KEY_F}${DAYS}${NC} days and ${KEY_F}${HOURS}${NC} hours ${KEY_F}${MINS}${NC} minutes"
    else
        TIME_REMAINING="Time remaining: Ended"
    fi

    # print header with time remaining
    local ITERATION_END_DATE="${ITERATION_END%%T*}"

    echo -e "${BOLD}${CYAN}Current Twork Iteration: $ITERATION_NAME ($ITERATION_START â†’ $ITERATION_END_DATE)${NC}"
    echo "$TIME_REMAINING"

    # query all tasks/chores assigned to you in current iteration
    local WIQL="SELECT [System.Id], [System.Title], [System.WorkItemType], [System.Parent], [System.State] FROM WorkItems WHERE [System.IterationPath] = '$ITERATION_PATH' AND [System.AssignedTo] = @Me AND [System.WorkItemType] IN ('Task', 'Chore')"
    local WIQL_JSON
    WIQL_JSON=$(jq -n --arg q "$WIQL" '{query: $q}')
    local WIQL_API="https://dev.azure.com/$AZURE_ORG/$AZURE_PROJECT/_apis/wit/wiql?api-version=7.0"
    local WIQL_RESPONSE
    WIQL_RESPONSE=$(curl -s -u ":$AZURE_DEVOPS_PAT" -H "Content-Type: application/json" -d "$WIQL_JSON" "$WIQL_API")

    local TASK_IDS
    TASK_IDS=$(echo "$WIQL_RESPONSE" | jq -r '.workItems[]?.id' | paste -sd, -)

    if [[ -z "$TASK_IDS" ]]; then
        t WARNING "No tasks or chores found for you in the current sprint."
        return 0
    fi

    # get details for all tasks/chores
    local DETAILS_API="https://dev.azure.com/$AZURE_ORG/$AZURE_PROJECT/_apis/wit/workitems?ids=$TASK_IDS&fields=System.Id,System.Title,System.WorkItemType,System.Parent,System.State&api-version=7.0"
    local TASKS_JSON
    TASKS_JSON=$(curl -s -u ":$AZURE_DEVOPS_PAT" "$DETAILS_API")

    # collect unique parent IDs
    local PARENT_IDS
    PARENT_IDS=$(echo "$TASKS_JSON" | jq -r '.value[] | .fields."System.Parent"? ' | sort -u | paste -sd, -)

    declare -A PARENTS

    # build associative array: id -> "type|state|title"
    if [[ -n "$PARENT_IDS" ]]; then
        local PARENT_API="https://dev.azure.com/$AZURE_ORG/$AZURE_PROJECT/_apis/wit/workitems?ids=$PARENT_IDS&fields=System.Id,System.Title,System.WorkItemType,System.State&api-version=7.0"
        local PARENTS_JSON
        PARENTS_JSON=$(curl -s -u ":$AZURE_DEVOPS_PAT" "$PARENT_API")
        while IFS='|' read -r id type state title; do
            PARENTS["$id"]="$type|$state|$title"
        done < <(echo "$PARENTS_JSON" | jq -r '.value[] | "\(.fields."System.Id")|\(.fields."System.WorkItemType")|\(.fields."System.State")|\(.fields."System.Title" | gsub("[\n\r]"; " "))"')
    fi

    for pid in $(echo "$PARENT_IDS" | tr ',' ' '); do
        [[ -z "$pid" ]] && continue
        IFS='|' read -r ptype pstate ptitle <<< "${PARENTS[$pid]}"
        pcolor=$(_status_colour "$pstate")
        short_title=$(_truncate_text "$ptitle" 42)
        printf "${BOLD}  -- %s %s [%b%s%b${BOLD}]: %s${NC}\n" "$pid" "$ptype" "$pcolor" "$pstate" "$NC" "$short_title"
        echo "$TASKS_JSON" | jq -r --arg pid "$pid" '
            .value[] | select(.fields."System.Parent" == ($pid|tonumber)) |
            "\(.fields."System.Id")|\(.fields."System.WorkItemType")|\(.fields."System.State")|\(.fields."System.Title")"' |
        while IFS='|' read -r cid ctype cstate ctitle; do
            ccolor=$(_status_colour "$cstate")
            cshort_title=$(_truncate_text "$ctitle" 42)
            printf -- "   * ${HDR_F}%s${NC} %s [%b%s%b]: %s\n" "$cid" "$ctype" "$ccolor" "$cstate" "$NC" "$cshort_title"
        done
    done

    # orphan tasks/chores
    echo "$TASKS_JSON" | jq -r '
        .value[] | select(.fields."System.Parent" == null) |
        "\(.fields."System.Id")|\(.fields."System.WorkItemType")|\(.fields."System.State")|\(.fields."System.Title")"' |
    while IFS='|' read -r cid ctype cstate ctitle; do
        ccolor=$(_status_colour "$cstate")
        cshort_title=$(_truncate_text "$ctitle" 42)
        printf "${HDR_F}%s${NC} %s [%b%s%b]: %s\n" "$cid" "$ctype" "$ccolor" "$cstate" "$NC" "$cshort_title"
    done
}

# ------------------------------------------
# asana related functions
# ------------------------------------------
# helper to generate the asana authorization header
function get_asa_header() {
    local asana_pat=$(_get_config "ASANA_PAT")
    if [[ -z "$asana_pat" ]]; then
        return 1
    fi
    echo "Authorization: Bearer $asana_pat"
}

# print current asana project details and tasks assigned to the user
function print_asana_status() {
    # if [[ $# -lt 2 ]]; then
    #     echo "Usage: print_asana_status <TODO>"
    #     return 1
    # fi
    # local asana_project_gid="$1"
    # local asana_pat="$2"

    local asana_project_gid=$(_get_config "ASANA_PROJECT_GID")
    local asana_pat=$(_get_config "ASANA_PAT")
    local auth_header=$(get_asa_header)
    if [[ $? -ne 0 || -z "$ASANA_PROJECT_GID" ]]; then
        t ERR "Missing Asana config (PAT or Project GID) in .env file."
        return 1
    fi

    # get project/iteration details
    local project_api="https://app.asana.com/api/1.0/projects/$asana_project_gid"
    local project_json=$(curl -s -H "$auth_header" "$project_api")
    local project_name=$(echo "$project_json" | jq -r '.data.name // "Unknown Project"')
    if [[ "$TERM_PROGRAM" == "vscode" ]]; then
        # if we are in vs code, replace complex emojis with stable nerd font icons
        local smh_star=$'\uf005 '
        project_name=$(echo "$project_name" | sed "s/ðŸƒâ€â™€ï¸/$smh_star/g")
    fi

    local due_on=$(echo "$project_json" | jq -r '.data.due_on')

    # calculate time remaining (handling empty due dates)
    local time_remaining="TIME REMAINING: ENDED"
    if [[ "$due_on" != "null" && -n "$due_on" ]]; then
        local end=$(date -d "$due_on" +%s 2>/dev/null || date -j -f "%Y-%m-%d" "$due_on" +%s)
        local now=$(date +%s)
        local secs_left=$((end - NOW))
        if (( secs_left > 0 )); then
            local days=$(( secs_left / 86400 ))
            time_remaining="TIME REMAINING: ${KEY_F}${days}${NC} days"
        fi
    fi

    # print header (uppercase to match your previous style)
    local display_date=$(echo "$due_on" | tr '[:lower:]' '[:upper:]')
    echo -e "${H2}CURRENT ASANA PROJECT: $project_name (DUE: $display_date)${NC}"
    echo -e "${H}${time_remaining}${NC}"
    printf "%s\n" "$br"

    # get your (hopefully) gid
    local me_gid=$(curl -sS -L --stderr /dev/null -H "$auth_header" "https://app.asana.com/api/1.0/users/me" | jq -r '.data.gid')

    # filter tasks assigned to you (pls)
    # local MY_TASKS=$(echo "$TASKS_JSON" | jq -c --arg me "$me_gid" '.data[] | select(.assignee.gid == $me)')
    # local MY_TASKS_DATA=$(echo "$TASKS_JSON" | jq -r --arg me "$me_gid" --arg pgid "$asana_project_gid" '
    local tasks_api="https://app.asana.com/api/1.0/tasks?project=$asana_project_gid&opt_fields=name,completed,assignee.gid,custom_fields.name,custom_fields.display_value,custom_fields.number_value,memberships.project.name,memberships.section.name"
    # local TASKS_JSON=$(curl -s -H "$auth_header" "$tasks_api")

    # # DEBUG check
    # if [[ $(echo "$TASKS_JSON" | jq '.data | length') -eq 0 ]]; then
    #     t ERROR "Asana returned 0 tasks for GID $asana_project_gid. Check if tasks are subtasks."
    #     return 1
    # fi

    # jq filter
    local tasks_data=$(curl -s -H "$auth_header" "$tasks_api" | jq -r --arg me "$me_gid" '
        .data[] | select(.assignee.gid == $me) |
        ( (.custom_fields[]? | select(.name | contains("Story Points")) | .number_value) // 0 ) as $p |
        ( (.custom_fields[]? | select(.name | contains("Ticket Type")) | .display_value) // "Task" ) as $t |
        ( first(.custom_fields[]? | select(.name == "RECON") | .display_value) // "---" ) as $id |
        ( [ .memberships[]? | select(.project.name | contains("Sprint")) ] | .[0].section.name // "No Section" ) as $s |
        "\($s)|\($id)|\($p)|\($t)|\(.name)|\(.gid)"
    ')

    if [[ -z "$tasks_data" ]]; then
        echo -e "${KEY_F}NO TASKS ASSIGNED TO YOU.${NC}"
        return 0
    fi

    local TOTAL_POINTS=0

    # display
    while IFS='|' read -r r_sec r_tid r_pts r_type r_name r_gid; do
        TOTAL_POINTS=$((TOTAL_POINTS + r_pts))

        # no emojis smh my head
        local clean_section=$(echo "$r_sec" | sed 's/[^[:alnum:][:space:]]//g' | xargs)

        # clean and trunc
        local clean_name=$(echo "$r_name" | sed -E "s/^${r_tid}[[:space:]]*[|:-]*[[:space:]]*//")
        [[ -z "$clean_name" ]] && clean_name="$r_name"

        local display_name=$(_truncate_text "$clean_name" 15)
        local s_color=$(_status_colour "$clean_section")
        local t_color=$(_status_colour "$r_type")

        # --- OUTPUT ---
        # FML FML FML FML FML FML
        display_name=""
        title="${r_gid%|*}"
        id="${r_gid#*|}"
        title=$(echo "$title" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
        id=$(echo "$id" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
        trunct_title=$(_truncate_text "$title" 32)
        # ignore this pls

        printf "${BOLD}$s_color%-12s>${NC} %-10s${NC} $t_color%-5s (%s pts)${NC} %s[ ${BLUE}%s${NC} ] ${DIM_F}%s${NC}\n" \
            "$clean_section" "$r_tid" "$r_type" "$r_pts" "$trunct_title" "$id"

    done <<< "$tasks_data"

    # summary
    echo -e "${H2_F}TOTAL WORKLOAD: ${H_F}${TOTAL_POINTS}${H2_F} POINTS${NC}"
}
