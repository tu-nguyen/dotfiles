#!/usr/bin/env bash
# ===================================================================== #
#
# TODO add comments later
# ===================================================================== #

# ------------------------------------------
# Pre-flight checks & Shell options
# ------------------------------------------
# guard: if not running interactively, don't do anything to avoid breaking non-interactive scripts
[[ $- != *i* ]] && return

# Input/output behavior
set -o vi                           # use vi-style line editing
set -o ignoreeof                    # prevent Ctrl-D from accidentally exiting the shell

# Shell options (shopt)
shopt -s autocd                     # if a directory name is typed alone, cd into it
shopt -s dotglob                    # include filenames beginning with a '.' in glob patterns
shopt -s nullglob                   # if a pattern matches nothing, expand to nothing instead of the pattern itself
shopt -s checkwinsize               # update LINES and COLUMNS after each command if terminal size changed
shopt -s cdspell                    # correct minor typos in directory names during 'cd'
shopt -s cdable_vars                # if an argument to 'cd' isn't a dir, assume it's a variable name
shopt -s checkhash                  # always check if a hashed command exists before executing
shopt -s sourcepath                 # force 'source' to use the PATH to find files
shopt -s no_empty_cmd_completion    # don't look for commands on PATH when trying to complete an empty line
shopt -s cmdhist                    # save multi-line commands as a single history entry
shopt -s histappend                 # append to history file instead of overwriting
shopt -s histreedit                 # allow user to re-edit a failed history substitution
shopt -s histverify                 # load history substitution into the editing buffer instead of executing immediately
shopt -s nocaseglob                 # case-insensitive globbing (used in pathname expansion)

# Enable programmable completion
if ! shopt -oq posix; then
    if [ -f /usr/share/bash-completion/bash_completion ]; then
        . /usr/share/bash-completion/bash_completion
    elif [ -f /etc/bash_completion ]; then
        . /etc/bash_completion
    fi
fi

# ------------------------------------------
# Load Custom bash files
# ------------------------------------------
# Dynamically loads all .bash_* files from your custom dotfiles directory (~/.config/dotfiles).
: ${DOTFILES_CONFIG_DIR:="$HOME/.config/dotfiles"}
: ${DOTFILES_CONFIG_FILE:="$DOTFILES_CONFIG_DIR/.dotfile_config"}
if [[ -f "$DOTFILES_CONFIG_FILE" ]]; then
    # echo "[ INFO ] Configuration loaded from $DOTFILES_CONFIG_FILE"
    . "$DOTFILES_CONFIG_FILE"
fi

if [[ -d "$DOTFILES_CONFIG_DIR" ]]; then
    # Load core/style first (explicitly)
    [[ -f "$DOTFILES_CONFIG_DIR/.init" ]] && . "$DOTFILES_CONFIG_DIR/.init"

    for file in "$DOTFILES_CONFIG_DIR"/.bash_*; do
        # Skip files we already loaded or specifically want to ignore
        case "$(basename "$file")" in
            .bash_functions|.bash_t|.bash_style|.init) continue ;;
        esac

        if [[ -f "$file" && -r "$file" ]]; then
            # Start timer
            start_time=$EPOCHREALTIME

            . "$file"

            # End timer (calculate difference in milliseconds)
            # Use bc for float math if needed, but simple string manipulation works too
            end_time=$EPOCHREALTIME

            # Calculate duration in ms (1 second = 1000ms)
            # Using simple math via $(( )) for integer comparison
            duration=$(echo "$end_time - $start_time" | awk '{print $1 * 1000}')

            # If it takes longer than 50ms, scream pls
            # (50ms is barely noticeable, 100ms is when I'll punch my monitor)
            if (( duration_ms > 50 )); then
                printf "${FILE_F}%-20s${NC} took ${RED}%0.2fms${NC}\n" "$(basename "$file")" "$duration"
            fi
        fi
    done

else
    msg="Config directory not found: $DOTFILES_CONFIG_DIR"
    declare -f t >/dev/null && t ERR "$msg" || echo -e "\033[0;31m[ ERR  ]\033[0m $msg"
fi

# ------------------------------------------
# Lesspipe & Pager Enhancements
# ------------------------------------------
# Allows 'less' to open and view contents of archives, pdfs, etc.
if [[ -x /usr/bin/lesspipe ]]; then
    eval "$(SHELL=/bin/sh lesspipe)"
fi

# ------------------------------------------
# Debian/Chroot Detection
# ------------------------------------------
# Set variable identifying the chroot you work in (used in the prompt below)
if [[ -z "${debian_chroot:-}" ]] && [[ -r /etc/debian_chroot ]]; then
    debian_chroot=$(qat /etc/debian_chroot)
fi

# ------------------------------------------
# Upkeep Stuff
# ------------------------------------------
_check_update_age() {
    local stamp_file="$DOTFILES_CONFIG_DIR/.last_update"
    local now=$(date +%s)

    # If the file doesn't exist, create it and exit silently
    if [[ ! -f "$stamp_file" ]]; then
        date +%s > "$stamp_file"
        return
    fi

    # Read the file safely; default to 0 if empty
    local last_update
    last_update=$(cat "$stamp_file" 2>/dev/null)
    last_update=${last_update:-0}

    # ensure last_update is actually a number to prevent the operand error
    if [[ ! "$last_update" =~ ^[0-9]+$ ]]; then
        date +%s > "$stamp_file"
        return
    fi

    local now=$(date +%s)
    local diff=$(( (now - last_update) / 86400 ))  # convert seconds to days

    if (( diff >= 14 )); then
        t "INFO" "It has been $diff days since your last 'dot-update'."
        t "INFO" "Run 'dot-update' to keep your tools fresh."
    fi
}
_check_update_age

dot-clean() {
    t "INFO" "Starting deep clean of temporary files and caches.."

    # Clean homebrew cache
    if command -v brew &>/dev/null; then
        t "INFO" "Removing old Homebrew downloads.."
        brew cleanup -s
        rm -rf "$(brew --cache)"
    fi

    # Clean uv/python caches
    if command -v uv &>/dev/null; then
        t "INFO" "Clearing uv cache..."
        uv cache clean
    fi
    t "INFO" "Removing recursive __pycache__ folders.."
    find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null

    # Clean Node/npm/Yarn
    t "INFO" "Clearing npm/yarn caches..."
    [[ -d "$HOME/.npm" ]] && rm -rf "$HOME/.npm"/*
    [[ -d "$HOME/.yarn/berry/cache" ]] && rm -rf "$HOME/.yarn/berry/cache"/*

    # Deep project cleaning (interactive)
    # This looks for node_modules in the current directory and subdirectories
    local node_dirs=$(find . -name "node_modules" -type d -prune | wc -l | xargs)
    if [[ "$node_dirs" -gt 0 ]]; then
        t "WARN" "Found $node_dirs 'node_modules' directories in the current path."
        read -p "Do you want to delete ALL node_modules in $(pwd)? (y/N) " confirm
        if [[ "$confirm" == [yY] ]]; then
            find . -name "node_modules" -type d -prune -exec rm -rf {} +
            t OK "All node_modules deleted."
        fi
    fi

    # Clear system logs/caches (safe subset)
    t "INFO" "Clearing user logs..."
    rm -rf "$HOME/Library/Logs"/*

    t OK "Deep clean complete! Your SSD thanks you."
}

# -----------------------------------------
# Greeting, MOTD, and Colors
# ------------------------------------------
# Display the Message of the Day if the 'motd' command is available
if [[ -f "$DOTFILES_CONFIG_DIR/.bash_motd" ]]; then
    # Assuming 'motd' is a function or alias defined in your .bash_ files
    motd auto
else
    [[ $(type -t t) == "function" ]] && t WARNING "MOTD file not found at $DOTFILES_CONFIG_DIR/.bash_motd\n"
fi

# ------------------------------------------
# Tools & Prompt
# ------------------------------------------
# Bat theme and man
# TODO: create my own?
# Further themes can be installed to '/home/valcr/.config/bat/themes', and are added to the cache with `bat cache --build`. For more information, see:
# https://github.com/sharkdp/bat#adding-new-themes
if [[ -z "$BAT_THEME" ]]; then
    export BAT_THEME='Visual Studio Dark+'
fi
export MANPAGER="bat -plman"
# export BAT_PAGER="less -RFK"
export BAT_PAGER=cat

# fnm (Fast Node Manager) with 24-hour Auto-Update check
FNM_PATH="$HOME/.local/share/fnm"
if [[ -d "$FNM_PATH" ]]; then
    export PATH="$FNM_PATH:$PATH"
    eval "$(fnm env --use-on-cd --shell bash)"

    # Check for Node LTS updates once every 24 hours (86400 seconds)
    TIMESTAMP_FILE="$DOTFILES_CONFIG_DIR/.node_update_timestamp"
    CURRENT_TIME=$(date +%s)
    UPDATE_INTERVAL=86400

    if [[ ! -f "$TIMESTAMP_FILE" ]] || (( CURRENT_TIME - $(qat "$TIMESTAMP_FILE") > UPDATE_INTERVAL )); then
        # determine latest LTS and set as default
        LTS_VER=$(fnm list | grep 'lts-latest' | awk '{print $2}')
        if [[ -n "$LTS_VER" ]]; then
            fnm default "$LTS_VER" >/dev/null
            echo "$CURRENT_TIME" > "$TIMESTAMP_FILE"
        fi
    fi
fi

# TODO: nvim

# direnv hook
export DIRENV_LOG_FORMAT=""
if command -v direnv &> /dev/null; then
    eval "$(direnv hook bash)"
fi

# Sets terminal tab title to "♥ CurrentDir"
set_win_title() {
    echo -ne "\033]2;♥ ${PWD##*/}\007"
}

export VIRTUAL_ENV_DISABLE_PROMPT=1

# Transient prompt for Starship
# _starship_transient_prompt() {
#     if [[ $? -eq 0 ]]; then
#         printf "${OK_F}» ${NC}"
#     else
#         printf "${ERR_F}» ${NC}"
#     fi
# }

if command -v starship &> /dev/null; then
    # Custom transient logic
    starship_precmd_user_func() {
        # _starship_transient_prompt
        set_win_title
    }

    eval "$(starship init bash)"
fi

# dircolors
if command -v dircolors >/dev/null 2>&1; then
    [[ -r $DOTFILES_CONFIG_DIR/.dircolors ]] && eval "$(dircolors -b $DOTFILES_CONFIG_DIR/.dircolors)" || eval "$(dircolors -b)"
fi

# alias ls='command ls -Fph --color=auto --group-directories-first'
# TODO: Use custom exa theme, see https://github.com/eza-community/eza-themes/tree/main/themes
if command -v eza >/dev/null 2>&1; then
    alias ls='eza --group-directories-first --color=always --icons'
else
    # Patch ls --dir first issue smh my head
    unset -f ls 2>/dev/null
    unalias ls 2>/dev/null
    # Fallback to standard ls logic if eza is missing
    if [[ "$(uname)" == "Darwin" ]]; then
        alias ls='ls -Gph'
    else
        alias ls='ls -Fph --color=auto --group-directories-first'
    fi
fi
